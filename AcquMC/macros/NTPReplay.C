//--Author	JRM Annand   28th Jun 2010	
//--Rev         
//--Update      
//--Description
//                *** Acqu++ <-> Root ***
// Online/Offline Analysis of Sub-Atomic Physics Experimental Data 
//
// NTPReplay.C
// Decode root file generated by Monte Carlo event generator TMCGenerator
// Histogram basic quantities

NTPReplay( Char_t* fname, Int_t qfRecon = -1 )
{
  // Histogram energies, momenta, from Tree created by kinematics generator
  // AcquMC....ensure physics library is loaded 1st
  gROOT->Reset();
  if (!gROOT->GetClass("TLorentzVector")) gSystem->Load("libPhysics");
  //
  // Tree file contains 4-momenta produced by MCGenerator
  TFile* tFile = new TFile( fname );
  TTree* tree = (TTree*)tFile->Get("h1");
  tree->Print();
  Int_t nbr = tree->GetNbranches();
  Int_t nparticle = (nbr - 3)/5;                  // # particles in reaction
  printf(" %d particles in experiment\n", nparticle );
  TObjArray* leaves = tree->GetListOfBranches(); // linked list of leaves
  printf(" %d leaves in branch\n",nbr);
  TIter nextlf( tree->GetListOfBranches() );
  char** hname = new char*[nbr];               // histogram parameters
  Float_t* p4i = new Float_t[nbr];
  for( Int_t n=0; n<nbr; n++ ){
    TBranch* lf = (TBranch*)nextlf();           // Double_t leaf
    hname[n] = lf->GetName();                 // its name
    tree->SetBranchAddress(hname[n], p4i+n);
  }
  Int_t nevent = tree->GetEntries();           // # events generated
  printf(" %d events started\n", nevent );
  //
  //  Create linked list of 1D histograms
  Int_t i,j,k;
  //  for(i=0,j=0; i<nparticle; i++) if( Track[i] ) j++;  // #particles tracked
  j = nparticle;
  printf(" %d final-state particles tracked\n", j );
  Int_t np4 = j;
  Int_t nhist = 4*j + 7;                              // # 1D histograms
  Int_t nchan = 1000;                                 // 1000 channels each
  Char_t* title;                                      // title is file name
  if( !(title = strrchr(fname,'/')) ) title = fname;
  else title++;
  TList* hl = new TList();
  TList* hAng = new TList();
  TH1F* h;
  for( i=0; i<nhist; i++ ){
    h = new TH1F( hname[i], title, nchan, 0, 0 );
    hl->AddLast(h);
  }
  Char_t angName[256];
  // Angular ranges (deg) for plotting
  Double_t thetaMin[] = {
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0
  };
  Double_t thetaMax[] = {
    0.5, 180.0, 180.0, 180.0, 180.0, 180.0, 180.0, 180.0, 180.0, 180.0,
    180.0, 180.0, 180.0, 180.0, 180.0, 180.0, 180.0, 180.0, 180.0, 180.0, 180.0
  };
  Double_t phiMin[] = {
    -200, -200, -200, -200, -200, -200, -200, -200, -200, -200,
    -200, -200, -200, -200, -200, -200, -200, -200, -200, -200, -200
  };
  Double_t phiMax[] = {
    200.0, 200.0, 200.0, 200.0, 200.0, 200.0, 200.0, 200.0, 200.0, 200.0,
    200.0, 200.0, 200.0, 200.0, 200.0, 200.0, 200.0, 200.0, 200.0, 200.0, 200.0
  };
  for( i=0; i<=np4; i++ ){
    sprintf( angName, "Theta_%d", i );
    h = new TH1F( angName, title, 180, thetaMin[i], thetaMax[i] );
    hAng->AddLast(h);
    sprintf( angName, "Phi_%d", i );
    h = new TH1F( angName, title, 180, phiMin[i], phiMax[i] );
    hAng->AddLast(h);
    sprintf( angName, "P_%d", i );
    h = new TH1F( angName, title, 1000, 0, 0 );
    hAng->AddLast(h);
  }    
  TIter next(hl);                             // list iterator
  TIter nextAng(hAng);                       // list iterator
  //
  // For some 4-momentum analysis
  TLorentzVector* P4 = new TLorentzVector[nparticle];
  TLorentzVector P4tot;
  TLorentzVector P4beamQF;
  i = 0;
  TH2F* h2a = new TH2F("Vertex-X-Y",title,300,-3,3,300,-3,3);
  TH2F* h2b = new TH2F("Vertex-Z-R",title,300,-3,3,300,-3,3);
  TH1F* h1a = new TH1F("Momentum-Balance",title,1000,-1,1);
  TH1F* h1b;
  if( qfRecon >= 0 ) h1b = new TH1F("QF-recon-Beam-Energy",title,2000,-5,5);
  //
  // Read events from branch
  Double_t r;
  Float_t* p;
  for(i=0; i<nevent; i++){
    next.Reset();
    nextAng.Reset();
    tree->GetEntry(i);
    p = p4i + 3;
    P4tot.SetXYZT(0,0,0,0);
    if( qfRecon >= 0 )P4beamQF.SetXYZT(0,0,0,0);
    for(j=0; j<=np4; j++,p+=5){
      P4[j].SetXYZT(p[0]*p[3],p[1]*p[3],p[2]*p[3],p[4]);
      if( j )P4tot += P4[j];
      else P4tot -= P4[j];
      if( j >= qfRecon ) P4beamQF += P4[j];
      h = (TH1F*)nextAng();
      h->Fill( P4[j].Theta() * TMath::RadToDeg() );
      h = (TH1F*)nextAng();
      h->Fill( P4[j].Phi() * TMath::RadToDeg() );
      h = (TH1F*)nextAng();
      h->Fill( P4[j].P() );
    }
    //    pi0_01 = *pi0_0 + *pi0_1;
    //    pi0_02 = *pi0_0 + *pi0_2;
    p = p4i;
    h2a->Fill( p4i[0], p4i[1] );
    r = TMath::Sqrt( p4i[0]*p4i[0] + p4i[1]*p4i[1] );
    h2b->Fill( p4i[2],r );
    h1a->Fill( P4tot.P() );
    if( qfRecon >= 0 ) h1b->Fill( P4beamQF.E() );
    while( (h = (TH1F*)next()) ){
      h->Fill(*p);
      p++;
    }
  }
  //
  // Setup of canvases
  Int_t ncanv = np4 + 2;                 // # canvases
  Char_t* cname[] = {                    // names
    "Vertex", "Beam", 
     "Particle_0",  "Particle_1",  "Particle_2",  "Particle_3", 
     "Particle_4",  "Particle_5",  "Particle_6",  "Particle_7", 
     "Particle_8",  "Particle_9", "Particle_10", "Particle_11", 
    "Particle_12", "Particle_13", "Particle_14", "Particle_15", 
    "Particle_16", "Particle_17", "Particle_18", "Particle_19",
  };
  Int_t xplot[] = {
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  };
  Int_t yplot[] = {
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  };
  Int_t nplot[] = {
    3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  };
  TCanvas* canv;
  next.Reset();                    // start of histogram list
  nextAng.Reset();                 // start of histogram list
  // Draw histograms
  for( i=0; i<ncanv; i++ ){
    canv = new TCanvas(cname[i],"MCtit",240,180,700,900);
    canv->SetFillStyle(4000);
    canv->Divide(xplot[i],yplot[i],0.01,0.01);
    j = 1;
    while( (h = (TH1F*)next()) ){
      canv->cd(j);
      h->Draw();
      if( j >= nplot[i] ) break;
      j++;
    }
    if( i ){
      for( k=0; k<3; k++ ){
	j++;
	h = (TH1F*)nextAng();
	canv->cd(j);
	if( k<2 ) h->Draw();
      }
    }
    else{
      canv->cd(4);
      h1a->Draw();
      canv->cd(5);
      h2a->Draw("colz");
      canv->cd(6);
      h2b->Draw("colz");
    }
  }
  return;
}

