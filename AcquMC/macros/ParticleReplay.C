//--Author	JRM Annand   11th Oct 2005	
//--Rev         
//--Update      JRM Annand   27th Jan 2010 Properties of particle combinations     
//--Description
//                *** Acqu++ <-> Root ***
// Online/Offline Analysis of Sub-Atomic Physics Experimental Data 
//
// MCReplay.C
// Decode root file generated by Monte Carlo event generator TMCGenerator
// Histogram basic quantities

ParticleReplay( Char_t* fname, Int_t icomb1 = 0, Int_t icomb2 = 0,
		Int_t qfRecon = -1 )
{
  // Histogram energies, momenta, from Tree created by kinematics generator
  // AcquMC....ensure physics library is loaded 1st
  gROOT->Reset();
  if (!gROOT->GetClass("TLorentzVector")) gSystem->Load("libPhysics");
  //
  // Tree file contains 4-momenta produced by MCGenerator
  TFile* tFile = new TFile( fname );
  TTree* tree = (TTree*)tFile->Get("TParticles");
  if( !tree ){
    printf("TParticles TTree structure not found in %s", fname);
    return;
  }
  tree->Print();
  //
  // Data Branch
  // Get info on variables (leaves of branches)
  TClonesArray* SaveParticles = new TClonesArray("TParticle"); 
  TClonesArray &arr = *SaveParticles;
  //  arr.BypassStreamer();
  tree->SetBranchAddress("Particles", &SaveParticles);
  TBranch* pbr = tree->GetBranch("Particles");
  Int_t nevent = pbr->GetEntries();           // # events generated
  printf(" %d events recorded\n", nevent );
  pbr->GetEntry(0);
  Int_t nparticle = arr.GetSize();
  //
  //  Create linked list of 1D histograms
  Int_t i,j,k;
  printf(" Beam & %d final-state particles tracked\n", nparticle-1 );
  //  Int_t nhist = 4*nparticle + 7;                  // # 1D histograms
  Int_t nhist = 6*nparticle;                          // # 1D histograms
  Int_t nchan = 1000;                                 // 1000 channels each
  Char_t hname[64];               // histogram parameters
  Char_t title[128];
  strcpy(title,"xxx");
  TList* hl = new TList();
  TList* hAng = new TList();
  TH1F* h;
  for( Int_t n=0; n<nparticle; n++ ){
    sprintf(hname,"Px_%d",n);
    printf("hist name = %s\n",hname);
    h = new TH1F( hname, title, nchan, 0, 0 );
    hl->AddLast(h);
    sprintf(hname,"Py_%d",n);
    printf("hist name = %s\n",hname);
    h = new TH1F( hname, title, nchan, 0, 0 );
    hl->AddLast(h);
    sprintf(hname,"Pz_%d",n);
    printf("hist name = %s\n",hname);
    h = new TH1F( hname, title, nchan, 0, 0 );
    hl->AddLast(h);
    sprintf(hname,"P_%d",n);
    printf("hist name = %s\n",hname);
    h = new TH1F( hname, title, nchan, 0, 0 );
    hl->AddLast(h);
    sprintf(hname,"E_%d",n);
    printf("hist name = %s\n",hname);
    h = new TH1F( hname, title, nchan, 0, 0 );
    hl->AddLast(h);
    sprintf(hname,"M_%d",n);
    printf("hist name = %s\n",hname);
    h = new TH1F( hname, title, nchan, 0, 0 );
    hl->AddLast(h);
    sprintf(hname,"Theta_%d",n);
    printf("hist name = %s\n",hname);
    h = new TH1F( hname, title, nchan, 0, 0 );
    hl->AddLast(h);
    sprintf(hname,"Phi_%d",n);
    printf("hist name = %s\n",hname);
    h = new TH1F( hname, title, nchan, 0, 0 );
    hl->AddLast(h);
  }
  //  return;
  Char_t angName[256];
  // Angular ranges (deg) for plotting
  Double_t thetaMin[] = {
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0
  };
  Double_t thetaMax[] = {
    0.5, 180.0, 180.0, 180.0, 180.0, 180.0, 180.0, 180.0, 180.0, 180.0,
    180.0, 180.0, 180.0, 180.0, 180.0, 180.0, 180.0, 180.0, 180.0, 180.0, 180.0
  };
  Double_t phiMin[] = {
    -200, -200, -200, -200, -200, -200, -200, -200, -200, -200,
    -200, -200, -200, -200, -200, -200, -200, -200, -200, -200, -200
  };
  Double_t phiMax[] = {
    200.0, 200.0, 200.0, 200.0, 200.0, 200.0, 200.0, 200.0, 200.0, 200.0,
    200.0, 200.0, 200.0, 200.0, 200.0, 200.0, 200.0, 200.0, 200.0, 200.0, 200.0
  };
  TIter next(hl);                             // list iterator
  // For some 4-momentum analysis
  TLorentzVector* P4 = new TLorentzVector[nparticle];
  TLorentzVector P4tot, P4comb;
  TLorentzVector P4beamQF;
  i = 0;
  TH2F* h2a = new TH2F("Vertex-X-Y",title,300,-3,3,300,-3,3);
  TH2F* h2b = new TH2F("Vertex-Z-R",title,300,-3,3,300,-3,3);
  TH1F* h1a = new TH1F("Momentum-Balance",title,1000,-1,1);
  TH1F* h1b;
  if( qfRecon >= 0 ) h1b = new TH1F("QF-recon-Beam-Energy",title,2000,-5,5);
  TH1F* h1cM = NULL;
  if( icomb1 || icomb2 ){
    Char_t cTitle[128];
    sprintf( cTitle, "Combined mass particles %d and %d", icomb1, icomb2 );
    h1cM =  new TH1F(cTitle,title,2000,0,0);
  }
  //
  // Read events from branch
  Double_t r,vx,vy,vz;
  for(i=0; i<nevent; i++){
    next.Reset();
    pbr->GetEntry(i);
    P4tot.SetXYZT(0,0,0,0);
    //    if( qfRecon >= 0 )P4beamQF.SetXYZT(0,0,0,0);
    TParticle* pp;
    for(j=0; j<nparticle; j++){
      pp = (TParticle*)arr[j];
      if( !pp ){
	printf("Particle not accessed from clones array Event: %d\n",i);
	break;
      }
      P4[j].SetXYZT(pp->Px(),pp->Py(),pp->Pz(),pp->Energy());
      if( j )P4tot += P4[j];
      else P4tot -= P4[j];
      //      if( j >= qfRecon ) P4beamQF += P4[j];
      h = (TH1F*)next();
      h->Fill( pp->Px() );
      h = (TH1F*)next();
      h->Fill( pp->Py() );
      h = (TH1F*)next();
      h->Fill( pp->Pz() );
      h = (TH1F*)next();
      h->Fill( pp->P() );
      h = (TH1F*)next();
      h->Fill( pp->Energy() );
      h = (TH1F*)next();
      h->Fill( P4[j].M() );
      h = (TH1F*)next();
      h->Fill( pp->Theta() * TMath::RadToDeg() );
      h = (TH1F*)next();
      h->Fill( pp->Phi() * TMath::RadToDeg() );
    }
    vx = pp->Vx();
    vy = pp->Vy();
    vz = pp->Vz();
    r = TMath::Sqrt(vx*vx + vy*vy);
    h2a->Fill(vx,vy);
    h2b->Fill(vz,r);
    h1a->Fill(P4tot.P());
    if( h1cM ){
      P4comb = P4[icomb1] + P4[icomb2];
      h1cM->Fill( P4comb.M() );
    }
  }
  return;
  //
  // Setup of canvases
  Int_t ncanv = np4 + 2;                 // # canvases
  Char_t* cname[] = {                    // names
    "Vertex", "Beam", 
     "Particle_0",  "Particle_1",  "Particle_2",  "Particle_3", 
     "Particle_4",  "Particle_5",  "Particle_6",  "Particle_7", 
     "Particle_8",  "Particle_9", "Particle_10", "Particle_11", 
    "Particle_12", "Particle_13", "Particle_14", "Particle_15", 
    "Particle_16", "Particle_17", "Particle_18", "Particle_19",
  };
  Int_t xplot[] = {
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
  };
  Int_t yplot[] = {
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  };
  Int_t nplot[] = {
    3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  };
  TCanvas* canv;
  next.Reset();                    // start of histogram list
  nextAng.Reset();                 // start of histogram list
  // Draw histograms
  for( i=0; i<ncanv; i++ ){
    canv = new TCanvas(cname[i],"MCtit",240,180,700,900);
    canv->SetFillStyle(4000);
    canv->Divide(xplot[i],yplot[i],0.01,0.01);
    j = 1;
    while( (h = (TH1F*)next()) ){
      canv->cd(j);
      h->Draw();
      if( j >= nplot[i] ) break;
      j++;
    }
    if( i ){
      for( k=0; k<2; k++ ){
	j++;
	h = (TH1F*)nextAng();
	canv->cd(j);
	h->Draw();
      }
    }
    else{
      canv->cd(4);
      h1a->Draw();
      canv->cd(5);
      h2a->Draw("colz");
      canv->cd(6);
      h2b->Draw("colz");
    }
  }
  return;
}

